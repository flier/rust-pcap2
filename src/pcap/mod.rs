use std::borrow::Cow;
use std::time::SystemTime;

mod header;
mod packet;
mod reader;
mod writer;

pub use self::reader::{mmap, open, parse, read, ParsePackets, ReadPackets, Reader};
pub use self::writer::{create, Builder, Writer};

/// The `Packet` struct contains information about a single captured packet.
#[derive(Clone, Debug)]
pub struct Packet<'a> {
    /// The time when the packet was captured.
    pub timestamp: SystemTime,
    /// The size of the packet as it was on the wire.
    pub actual_length: usize,
    /// The contents of the packet (possibly truncated to `actual_length` bytes during capture).
    pub payload: Cow<'a, [u8]>,
}

impl<'a> Packet<'a> {
    pub fn new(payload: &'a [u8]) -> Self {
        Self::with_timestamp(payload, SystemTime::now())
    }

    pub fn with_timestamp(payload: &'a [u8], timestamp: SystemTime) -> Packet<'a> {
        Packet {
            timestamp,
            actual_length: payload.len(),
            payload: payload.into(),
        }
    }
}

#[cfg(test)]
pub mod tests {
    use pcap::header::Magic;

    lazy_static! {
        pub static ref PACKET_BE_US: Vec<u8> = vec![
            0xa1, 0xb2, 0xc3, 0xd4, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x65, 0x56, 0x50, 0x6e, 0x1a,
            0x18, 0x2b, 0x0a, 0xd0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3c, 0x44, 0x41,
            0x54, 0x41,
        ];
        pub static ref PACKET_BE_NS: Vec<u8> = vec![
            0xa1, 0xb2, 0x3c, 0x4d, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x65, 0x56, 0x50, 0x6e, 0x1a,
            0x18, 0x2b, 0x0a, 0xd0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3c, 0x44, 0x41,
            0x54, 0x41,
        ];
        pub static ref PACKET_LE_US: Vec<u8> = vec![
            0xd4, 0xc3, 0xb2, 0xa1, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x1a, 0x6e, 0x50, 0x56,
            0xd0, 0x0a, 0x2b, 0x18, 0x04, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x44, 0x41,
            0x54, 0x41,
        ];
        pub static ref PACKET_LE_NS: Vec<u8> = vec![
            0x4d, 0x3c, 0xb2, 0xa1, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x1a, 0x6e, 0x50, 0x56,
            0xd0, 0x0a, 0x2b, 0x18, 0x04, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x44, 0x41,
            0x54, 0x41,
        ];
        pub static ref PACKETS: Vec<(&'static [u8], Magic)> = vec![
            (&PACKET_BE_US, Magic::ByteSwap),
            (&PACKET_BE_NS, Magic::NanoSecondResolutionByteSwap),
            (&PACKET_LE_US, Magic::Normal),
            (&PACKET_LE_NS, Magic::NanoSecondResolution),
        ];
        pub static ref NANO_PACKETS: Vec<(&'static [u8], Magic)> = vec![
            (&PACKET_BE_NS, Magic::NanoSecondResolutionByteSwap),
            (&PACKET_LE_NS, Magic::NanoSecondResolution),
        ];
    }
}
